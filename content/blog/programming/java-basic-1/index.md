---
category : Java
title: "Java 기초 - 1"
date: "2020-07-02"
tags : ["Java"]
featuredImage: thumbnail.png
---

# 자바 프로그래밍 시작
자바로 프로그래밍을 하기 위해서는 우선 개발자 컴퓨터에 **JDK**가 설치되어 있어야 한다.<br/>
JDK는 Java Development Kit의 약자로, 자바 개발에 필요한 많은 라이브러리와 플랫폼이 포함되어 있다.<br/>
자바 프로그램을 실행하기 위해서는 JRE(Java Runtime Environment)만 있으면 되지만, 자바 프로그램을 만들기 위해서는 반드시 JDK가 있어야 한다.<br/>
JDK 설치 방법은 아래를 참고한다. (* Windows OS 기준)

### 1. JDK 다운로드
[오라클 사이트](https://www.oracle.com/java/technologies/javase-downloads.html)에서 본인의 컴퓨터 환경에 맞게 JDK 설치 파일을 다운로드한다.

### 2. JDK 설치
JDK 설치 파일을 실행한다. JDK가 설치된 경로의 bin 디렉토리로 이동하면, javac.exe와 java.exe 파일을 확인 할 수 있다.<br/>
이 두 파일은 명령 프롬프트의 어느 경로에서든 실행 가능해야하므로 이 파일들이 설치된 경로를 **환경 변수 Path로 설정**할 필요가 있다.<br/>

- ``javac.exe`` : **자바 컴파일러** <br/>
    java 파일을 class 파일로 컴파일 시켜준다.
- ``java.exe`` : **자바 런처** <br/>
    JVM을 구동시키고, JVM 위에 Java Program을 올리는 초기 준비를 해준다.

### 3. 환경 변수 Path 설정
1. 내 PC 오른쪽 버튼 클릭 → 속성 → 시스템 → 고급 시스템 설정 → [고급] 탭의 [환경 변수] 클릭
2. path라는 변수 명으로 javac.exe, java.exe가 다운로드 되어있는 경로를 환경 변수로 지정한다.

# 자바 프로그램과 실행 원리
일반적인 프로그램은 OS 위에서 동작한다. OS 별로 똑같은 기계어라도 해석하는 방식이 다르기 때문에 그에 따라 프로그램의 구현 방식도 달라진다.<br/>
자바는 **자바 프로그램과 시스템 사이에 JVM을 두어 각 플랫폼마다 존재하는 차이점을 해결**한다.<br/>
자바 소스 코드를 컴파일 중간 기계어인 **바이트 코드로 변환**되는데, 이 바이트 코드를 **JVM이 각 운영체제에 맞게 기계어로 변환**한다.<br/>
JVM 역시 OS 관점에서 하나의 프로그램이고, 운영체제 위에서 동작하기 때문에 **OS 마다 JVM이 다르다.**<br/>


### 자바 프로그램의 실행 구조
```
+----------------------+
|     Java Program     |
+----------------------+
| Java Virtual Machine |  OS별로 존재하는 차이점을 JVM이 중간에서 해결해준다
|         (JVM)        |  => 운영체제에 상관 없이 프로그램이 실행된다
+----------------------+    
|          OS          |
+----------------------+
|        Hardware      |
+----------------------+
```

### JVM 구성
1. **자바 인터프리터**<br/>
자바는 바이트 코드를 읽고 해석하는 인터프리터 언어다. JVM이 그 역할을 한다.

2. **클래스 로더**<br/>
동적으로 클래스를 로딩시켜준다.

3. **JIT (Just-In-Time) 컴파일러**<br/>
런타임시 가상 기계 상에서만 돌아가는 자바 바이트 코드를 해당 플랫폼에 맞는 기계어로 변환해준다.

4. **가비지 컬렉터**<br/>
사용하지 않는 메모리를 회수해준다.

### 자바 컴파일러와 바이트 코드
```
+-----------+          +------------+
| test.java | -------> | test.class |
+-----------+  컴파일러  +------------+
 소스코드 파일               클래스 파일
                    (자바 바이트코드로 이뤄짐)
```
자바 컴파일러는 소스 코드 파일을 **자바 가상 머신이 이해할 수 있는 '자바 바이트 코드'로 변환**시켜 준다.
- 자바 바이트 코드 : **명령문**이라고도 하며, 크기가 기본적으로 **1바이트 단위**여서 자바 바이트 코드라 한다.

# 기본 구조
```java
class HelloWorld { // 클래스
    public static void main(String[] args){ // 메소드
        System.out.println("Hello, World");
    }
}
```

# 주석
1. 블록(block) 단위의 주석 : /* ~ */
```java
/*
	블록 단위
	주석 영역
*/
```

2. 행(line) 단위 주석 : //
```java
// 라인 단위
// 주석 영역
```

---

# 변수와 자료형
## 변수
데이터의 저장과 참조를 위해 **'할당된 메모리 공간'에 붙여진 이름**
```java
int num;
```

**초기화** <br/>
변수에 처음 값을 대입하는 일
```java
int num = 20; // 변수 선언과 동시에 값을 초기화한다.
```

## 기본 자료형
자바에서 기본적으로 제공하는 자료형을 **기본 자료형(Primitive Data Type)**이라 한다.<br/>
기본 자료형은 변수에 실제 값이 저장되며, 각 자료형이 사용할 공간의 크기가 정해져있다.

|  | **정수** | **실수** | **문자** | **참/거짓** |
|:---:|:---:|:---:|:---:|:---:|
| **1byte** | byte | - | - | boolean |
| **2byte** | short | - | char | - |
| **4byte** | int | float | - |  - |
| **8byte** | long | double | - |  - |

### 정수 : byte, short, int, long
양수, 음수, 0을 나타내는데 사용하는 자료형이다.<br/>
네 개의 정수 자료형은 정수의 표현에 사용하는 **메모리 공간의 크기**가 다르다.<br/><br/>

자바 가상머신은 **정수형 연산**을 4byte인 **int형으로 진행**한다.<br/>
byte형 변수나 short형 변수에 저장된 값을 대상으로 연산을 진행하면 이를 먼저 **int형 값으로 변경**해버린다.
- long(8byte) → int(4byte) 형변환은 데이터 손실이 발생하므로 이뤄지지 않는다.

```java
short num1 = 100;
short num2 = 200;

short res = num1 + num2;
// !!!Error!!! incompatible types : possible lossy conversion from int to short
// 값을 더하는 과정이 아니라 더한 값인 int형 값을 short형 변수에 담는 과정에서 에러가 발생한 것 
```
=> 연산을 동반하는 상황에서는 int형을 사용하도록 한다.

### 실수 자료형 : float, double

### 문자 자료형 : char
하드웨어는 수밖에 인식을 못하기 때문에 소프트웨어는 **문자에 대한 특정 정수 값을 부여하는 방법으로 문자를 표현**한다.<br/>
예를 들어 문자 'A'는 숫자 65로 표현하기로 약속을 하는 것이다.<br/>
이러한 **문자의 표현에 대한 약속**을 **문자 셋(Character Set)**이라 한다.<br/>
문자를 정해진 코드 값으로 변환하는 것을 **'문자 인코딩(encoding)'**이라 하며, 반대로 코드 값을 문자로 변환하는 과정을 **'문자 디코딩(decoding)'**이라 한다.<br/><br/>

문자 셋의 설계는 지역 및 국가별로 각각 이루어진다. 대표적으로 아스키(ASCII) 코드는 영문자, 숫자, 특수 문자 등을 1바이트로 표현한다.<br/>
문자 셋은 그 수가 다양하므로 데이터를 주고받거나 여러 국가의 언어를 동시에 표현하는 상황에서 문제가 발생된다.<br/>
모든 나라의 문자를 수용하여 **전 세계적으로 사용할 수 있는 문자 셋**을 설계하게 되는데, 이를 **유니코드(Unicode)**라고 한다.<br/>
유니코드의 1바이트는 아스키 코드 값과 호환되며, 그 밖의 문자를 2바이트나 그 이상으로 조합해 표현한다.<br/><br/>

문자를 변수에 대입하면 컴파일 과정에서 **유니코드 값으로 치환**되며, **실제 저장되는 값은 문자가 아닌 유니코드 값**이다.

```java
char a = 'A'; // 실제로는 65가 저장된다.
```

### 논리 자료형 : boolean

## 참조 자료형
기본 자료형을 제외한 모든 값은 참조 자료형(Reference Data Type)이다.<br/>
변수에 저장된 값은 **객체가 저장된 메모리(heap)의 주소 값이며 그 주소를 이용해 객체를 참조**한다.

# 형 변환
서로 다른 자료형의 데이터를 연산 할 수 없으므로 자료형을 하나로 일치시켜줘야 한다.
```java
int num1 = 10;
long num2 = 3147483547L
System.out.println(num1 + num2);
```
이 경우는 int형 변수에 담긴 값을 long형으로 변환해야 데이터 손실 없이 연산이 가능하다.
1. 변수 num1에 저장된 값을 long형으로 변환하여 메모리에 임시 저장 (자동 형 변환)
2. 이 변환된 값을 num2에 저장된 값을 대상으로 덧셈을 진행

⇒ 이러한 일련의 과정을 **형 변환**이라고 한다.<br/><br/>

형 변환에는 크게 '자동 형 변환'과 '명시적 형 변환'으로 구별 할 수 있다.

### 자동 형 변환
자동 형 변환이 일어나는 규칙은 아래와 같다.

1. 바이트 크기가 **작은 자료형에서 큰 자료형**으로 일어난다.
2. 자료형의 크기에 상관없이 **정수 자료형보다 실수 자료형이 우선**으로 한다.

<br/>

**자동 형 변환이 일어나는 방향**
```
	-> [short]
[byte]		   -> [int] -> [long] -> [float] -> [double]
	-> [char] 
```

### 명시적 형 변환
바이트 크기가 큰 자료형에서 작은 자료형으로 대입하거나,<br/>
실수 자료형에 정수 자료형을 대입하는 과정에서는 명시적 형 변환을 해줘야 한다.
```java
int num1 = 1;
byte num2 = (byte)num1;
```

---

# 클래스
클래스(Class) = 데이터(Data) + 메소드(Method)<br/>
- **데이터** : **프로그램 상에서 유지하고 관리**해야 할 데이터
    - 데이터는 **'변수의 선언'**을 통해 유지 및 관리가 되고 **변수에 저장된 데이터는 '메소드의 호출'을 통해 처리** 됨
- **기능** : **데이터를 처리하고 조작**하는 기능

## 클래스의 구성
```java
public class Person {
   // 인스턴스 변수
   String firstName;
   String lastName;

   // 인스턴스 메서드
   public String getFullName() {...}
}
```
### 인스턴스 변수 
클래스 내에 선언하여 객체의 속성을 나타내는 변수로서, **멤버 변수, 필드(Fields)** 라고 불리기도 한다.<br/>
같은 클래스 내에 위치한 메소드 내에서 접근 가능하다.

### 인스턴스 메소드
클래스 내에 정의된 메소드

## 인스턴스
클래스는 무언가를 찍어내는 틀과도 같다. 틀을 이용해 모양을 찍어내듯이 new 키워드를 사용해 인스턴스를 생성하여 사용한다.<br/>
```java
new Person();
```
인스턴스는 실제 메모리 공간(heap)에 존재하게 된다. <br/>
인스턴스를 사용하기 위해서는 **인스턴스를 참조할 수 있는(가리키고 있을 수 있는) 참조변수**가 필요하다.<br/>
new 키워드로 인스턴스를 생성하면 생성된 **인스턴스의 주소 값이 반환**되고, **참조 변수에는 그 주소 값이 저장**되는 형태이다.
```java
Person p1 = new Person();
```

### 참조변수의 특성
1. 참조변수도 변수이므로 **참조하는 인스턴스를 바꿀 수 있다.**

```java
Person p1 = new Person();
// ...
p1 = new Person(); // 새 인스턴스 참조
```

2. 메소드의 **매개변수로 참조변수를 선언 할 수 있다.**

```java
public String getPersonInfo(Person person) { 
   return "name : " + person.getName() + ", age : " + person.getAge();
}
```

3. 참조변수에 **null을 대입하여 인스턴스와의 관계를 끊을 수 있다.**

```java
Person p1 = new Person();
// ...
p1 = null;
```

# 생성자(constructor)
생성자는 **인스턴스 생성과 동시에 멤버 변수의 초기화**를 하기 위한 메소드로, 개발자의 편의를 위해 문법으로 만들어둔 것이다.<br/>
일반 메소드의 모습과 비슷하지만 차이점이 존재한다.<br/>
- 생성자의 이름은 **클래스의 이름과 동일**해야 한다.
- 생성자는 **값을 반환하지 않고 반환형도 표시하지 않는다.**

⇒ 위 조건을 만족하면 **자바 컴파일러**에 의해 **생성자로 인식**된다.

```java
class Person {
   String name;
   int age;

   // 생성자
   public Person(String name, int age) {
	 this.name = name;	
	 this.age = age;
   }
}
```

## 디폴트 생성자
**생성자를 생략한 상태의 클래스를 정의**하면 자바 컴파일러가 **'디폴트 생성자'** 라는 것을 클래스의 정의에 넣어준다.

```java
public class Person {
   // ...
   // 컴파일러에 의해 자동 삽입되는 디폴트 생성자
   public Person(){}
   //...
}
```

# 정보 은닉
자바에서 말하는 정보는 클래스의 '인스턴스 변수'를 의미한다.<br/>
즉, 정보를 은닉한다는 것은 **인스턴스 변수를 숨긴다**는 것이다.

## 정보 은닉을 해야하는 이유
인스턴스 변수에 바로 접근하여 값을 변경 할 경우 컴파일 에러는 발생하지 않지만,<br/>
**값의 안정성 체크가 되지 않고 그로인해 논리적으로 잘못된 값이 할당** 될 수 있다.

```java
class MyDate {
    int year;
    int month;
    int day;
}

public class Test {
    public static void main(String[] args) {
        MyDate birthday = new MyDate();
        birthday.year = 1993;
        birthday.month = 13; // 13월은 존재하지 않음.
        // 인스턴스 변수에 바로 접근해서 값을 변경하면, 논리적인 에러임에도 컴파일 오류가 발생하지 않는다.
        // => 안정성 체크가 안된다!
    }
}
```

## 정보 은닉 구현
private 접근 제어자를 이용해 인스턴스 변수를 클래스 내부에서만 접근하도록 제어하고, 외부에서 인스턴스 변수에 접근 할 수 있도록 두개의 메소드를 제공한다.

### setter
인스턴스 변수의 값을 설정하는 용도로 정의된 메소드

### getter
인스턴스 변수의 값을 참조하는 용도로 정의된 메소드

## 접근 제어자
접근의 허용 수준을 결정 할 때 사용하는 키워드

### 클래스의 정의 대상
public, default 를 접근 제어자로 선언 할 수 있음

- ``public`` : **어디서든** 인스턴스 생성이 가능하다
- ``default`` : **동일 패키지로 묶인 클래스 내에서만** 인스턴스 생성을 허용한다

<br/>

**지켜야 할 사항**
- 하나의 소스 파일에 **하나의 클래스만 public으로 선언**한다
- **소스 파일의 이름과 public으로 선언된 클래스의 이름을 일치**시킨다

### 인스턴스 멤버 대상
public, protected, private, default 를 접근 제어자로 선언 할 수 있음

- ``private`` : **동일한 클래스에 정의된 메소드**에서만 접근 가능
- ``default`` : **동일 패키지로 묶인 클래스** 내에서만 접근 가능
- ``protected`` : 동일한 패키지가 아니어도 **상속 받은 클래스**인 경우 접근 가능
- ``public`` : **어디서든** 접근이 가능하다

⇒ 접근 허용 범위 : public > protected > default > private

## 캡슐화
**하나의 목적을 이루기 위해 관련 있는 모든 것을 하나의 클래스에 담아두는 것**으로 객체지향 기반의 클래스 설계에 있어서 가장 중요하다.

- 캡슐화는 절대로 **클래스를 크게 만들라는 뜻이 아니다.** <br/>
해당 클래스와 관련 있는 내용을 하나의 클래스에 모두 담되 부족하게 담아서도 넘치게 담아서도 안된다.


# Reference
- [윤성우의 열혈 Java 프로그래밍](http://www.yes24.com/Product/Goods/43755519?OzSrank=1)
- [Do it! 자바 프로그래밍 입문](http://www.yes24.com/Product/Goods/62281686?OzSrank=7)