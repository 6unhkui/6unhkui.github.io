---
category : Javascript
title: "변수와 자료형"
date: "2020-12-01"
tags : ["Javascript", "Book"]
featuredImage: thumbnail.png
---

> [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)를 읽고 학습한 내용을 간략하게 정리한 글입니다.<br/>
> 자바스크립트 기본 개념과 동작 원리를 잘 다루고 있는 책입니다. 상세한 내용은 책을 참고해주세요.

# 변수
변수는 값을 저장하기 위해 확보한 메모리 공간에 붙인 이름으로, **메모리 공간을 식별하기 위한 식별자**다.<br/>
변수가 기억하는 값은 실제 값이 아닌 **메모리 공간의 주소 값**으로,
컴파일러 혹은 인터프리터에 의해 값이 저장된 **메모리 공간의 주소로 치환되어서 사용**된다.<br/>
변수를 사용하기 위해서는 먼저 변수 선언을 하여 자바스크립트 엔진에게 식별자의 존재를 알려야한다.<br/>

### 변수 선언
변수 선언이란 값을 저장하기 위해 **메모리 공간을 확보**하고 **변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)**해서
**값을 저장 할 수 있게 준비하는 것**을 말한다.
```javascript
var a;
```
자바스크립트는 **예약된 키워드(var, let, const)를 사용해 변수를 선언**한다.<br/>
정적 타입 언어와는 달리 변수를 선언할 때 타입을 선언하지 않으며 **어떤 타입의 값이라도 자유롭게 할당** 할 수 있다.
```javascript
var a = 1;
console.log(typeof a); // number
a = '안녕';
console.log(typeof a); // string
```

### 선언된 변수는 어떻게 관리될까?
변수 이름을 비롯한 모든 식별자는 **실행 컨텍스트**에 등록된다.<br/>
실행 컨텍스트는 **자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역**이다.<br/>
자바스크립트 엔진은 **실행 컨텍스트를 통해 식별자와 스코프를 관리**한다.<br/>
변수 이름과 변수 값은 **실행 컨텍스트의 key-value 형식인 객체(렉시컬 환경)**에 등록되어 관리된다.

### 변수 선언의 실행 시점과 변수 호이스팅
자바스크립트 엔진은 **런타임 이전에 소스 코드의 평가 과정**을 거치면서 소스 코드를 실행하기 위한 준비를 한다.<br/>
이때 소스 코드 실행을 위한 준비 단계인 **평가 과정에서 변수 선언을 포함한 모든 선언문을 소스 코드에서 찾아내 먼저 실행**한다.<br/>
그리고 평가 과정이 끝나면 **선언문을 제외한 소스 코드를 한 줄씩 순차적으로 실행**한다.

```javascript
console.log(a); // undefined
var a = 1;
console.log(a); // 1
```
위 코드에서 변수 a를 선언문 코드 이전에 참조해도 에러가 뜨지 않고 undefined로 참조 가능한 이유 역시 평가 단계에서 이미 선언문이 실행되고 선언과 동시에 undefined로 초기화되었기 때문이다.<br/>
(참고로 var 키워드는 선언과 동시에 암묵적으로 undefined로 초기화가 이뤄지는 반면, let과 const는 선언과 초기화가 분리되어 진행된다. 그렇지만 호이스팅이 발생하는 것은 마찬가지다. 자세한 내용은 [var, let, const 키워드의 차이점](https://github.com/6unhkui/programming/javascript-variable-keyword)에서 정리한다.)<br/>
이렇듯 마치 **변수 선언문이 코드 최상단으로 끌어올려진 것처럼 동작하는 자바스크립트의 고유한 특징**을 **변수 호이스팅**이라고 한다.<br/>
호이스팅은 변수 뿐만 아니라 var, let, const, function, class 키워드로 선언한 모든 선언문에서 일어난다.<br/>


# Data Types
자바스크립트(ES6)는 원시 타입(Primitive Type) 6개와 객체 타입(Object Type)을 제공한다.

## 원시 타입(Primitive Type)
원시 타입 데이터는 변수에 할당 될 때 메모리 상에 **고정된 크기로 저장되고 메모리 공간엔 실제 값을 보관**한다.<br/><br/>
원시 타입은 **변경 불가능한 값(immutable value)**이다. 여기서 변경 불가능한 값이라는 것은 변수에 다른 값을 할당 할 수 없다는 것이 아니라 변수와 바인딩 된 메모리 공간에 저장된 원시 값 자체를 변경 될 수 없다는 것을 의미한다. 값이 변경되면 새로운 메모리 공간에 변경된 값이 저장되고 변수는 새로운 메모리 공간 주소 값을 바인딩한다. 즉, **값의 변경은 재할당**을 통해 이뤄지는 것이다.<br/><br/>

원시 타입 변수를 복사할 경우에는 **실제 값이 복사되어 전달**된다.<br/>
```javascript
let origin = 123;
let copy = origin;
origin = 456;
console.log(copy); // 123
```
origin 변수와 copy 변수는 서로 다른 메모리 공간을 가지고 있기 때문에, origin 변수의 값이 변경되도 copy 변수에 영향을 주지 않는다.



### 1. Number
자바스크립트는 모든 숫자를 **실수**로 처리하며, 정수로만 표현하기 위한 데이터 타입은 존재하지 않는다.<br/>
```javascript
console.log(typeof 1); // number
console.log(typeof 1.0); // number
console.log(1 === 1.0); // true
```
이 외에도 3가지 상징적인 값도 표현 할 수 있다.
1. Infinity : 양의 무한대
2. -Infinity : 음의 무한대
3. NaN(Not A Number) : 산술 연산 불가

### 2. String
자바스크립트에서 String은 원시 타입이다. 또한 문자와 문자열을 구분 짓지 않고 String 타입으로 관리한다.<br/>
표현 방식은 **작은 따옴표(''), 큰 따옴표(""), 백틱 기호(\`\`)**로 텍스트를 감싸면 된다.
```javascript
let str;
str = '문자열';
str = "문자열";
str = `문자열`;
```

### 3. Boolean
참(ture)과 거짓(false)으로 이루어져 있다.
```javascript
let bool = 1 < 10;
console.log(bool); // true

bool = 1 > 10;
console.log(bool); // false
```

### 4. undefined
**var 키워드로 선언된 변수에 암묵적으로 할당되는 값**이다. <br/>
실제 값이 할당되기 전까지 메모리 공간에 저장되어 있는 값이다.
```javascript
console.log(a); // undefined
var a = 1;
```

### 5. null
**값이 없다는 것을 의도적으로 명시**할 때 사용하는 값이다
```javascript
let a = 1;
a = null;
console.log(a); // null
```

### 6. Symbol
심볼은 **유일한 식별자**를 만들고 싶을 때 사용한다.<br/>
주로 **객체의 프로퍼티 키를 유일한 프로퍼티 키로 만들기 위해** 사용한다.

```javascript
const id = Symbol('id');
const id2 = Symbol('id');
console.log(id === id2); // false
```

<br/>

## 객체 타입(Object Type)
다른 말로 **참조 타입(Reference Type)**이라 부른다.<br/>
객체 타입 데이터는 **메모리 공간의 크기를 사전에 정해둘 수 없으며**, 변수에는 **heap에 저장된 객체의 참조 값**이 저장된다.<br/><br/>

객체 타입은 원시 타입과는 달리 **변경 가능한 값(mutable value)**이다.<br/>
**값의 재할당 없이도 프로퍼티 값을 추가, 수정, 삭제** 할 수 있다.
객체를 생성하고 관리하는 방식은 매우 복잡하고 비용이 많이 든다. 객체를 변경 할 때마다 원시 값처럼 이전 값을 복사해서 새롭게 생성하는 것은 메모리의 효율적 소비가 어렵고 성능이 나빠지기 때문에 변경 가능한 값으로 설계된 것이다. 원시 값과 달리 여러개의 식별자가 하나의 객체를 공유 할 수 있다.
<br/><br/>

객체 타입 변수를 복사할 경우에는 **참조 값이 복사되어 전달**된다.<br/>
```javascript
let origin = {name : 'Jane', age : 20};
let copy = origin;
origin.name = 'Serina';
console.log(copy.name); // 'Serina'
```
origin 변수와 copy 변수의 메모리 공간의 주소 값은 다르지만 그 메모리에 저장된 참조 값은 동일하다.<br/>
즉 **하나의 객체를 공유**하게 되는 것이다.


## 정리
|  | 원시 타입 | 객체 타입 |
|:---:|:---:|:---:|
| 종류 | number, string, boolean, undefined, null, symbol | 객체, 함수, 배열, 정규 표현식 등 |
| 변경 여부 | 변경 불가능한 값 | 변경 가능한 값 |
| 메모리 공간에 저장된 값 | 실제 값 저장 | 참조 값 저장 |
| 변수를 복사할 경우 | 실제 값을 복사하여 전달 | 참조 값을 복사하여 전달 |
